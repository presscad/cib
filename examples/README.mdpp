# Examples aka CIB Architecture Details
 We will learn about bits and peices of CIB architecture through code generated by `cib`. We will start with trivial example and slowly build on that to understand what CIB architecture requires in more complex cases. Except the declaration of proxy classes that client's will use, all other code generated by cib are solely for compilers. But we will look into generated code to understand CIB architecture.

**Note**: All examples mentioned below are real programs, however tiny, they are working piece of code and are actually part of automated tests of cib:
- Almost all examples contain a library and a client executable.
- Library consists of a public header and a source file.
- Most functions simply return an `int`.
- `cib` tool is used on public header that
    - generates glue code for library and clients.
    - generates cibified headers that becomes part of the SDK.
- Client is an executable that tests correct behavior of library.

## Types of Examples:
There are 3 types of examples:
1. Examples that tests basic C++ feature of cibified SDK.
2. Examples that tests cibified SDK offers **backward compatibility**, such tests have `bkwd-compatibility` in it's name.
3. Examples that tests cibified SDK offers **forward compatibility**, tests that have `forwd-compatibility` in it's name.

## Example - A Simple Class
This example explains the basic building blocks of CIB architecture and how CIB defines it's own ABI that ensures ABI stability. This example doesn't demonstrate ABI stability yet, which is done in other examples, but it is just to explain the fundamentals of CIB architecture and CIB tool.

For details please see [A Simple Class example](010-simple-class)

## Example - Simple Class and Backward Compatibility
This example illustrates the fact that change in data member of a class doesn't affect ABI stability because CIB uses bridge pattern and that is known to isolate client and library from changes in data members.

For details please see [Simple Class and Backward Compatibility](015-simple-class-and-bkwd-compatibility)

## Example - Virtual Function
This example explains how runtime polymorphic calls can be made across component boundary in an ABI stable way. This example is just to explain required building blocks. In the next example we will consider the ABI stability.

For details please see [Virtual Function example](020-virtual-function)

## Example - Virtual Function and Backward Compatibility

This is the example that demonstrates how CIB ensures ABI stability even when virtual table is disrupted. This example is built on the previous one and creates a new library with disrupted virtual table. Then it runs both, the new client and also the old client (i.e. the client of previous example) with the new library. Both clients should work as expected with the new library. That demostrates CIB ensures ABI stability when virtual table is disrupted.

For details please see [Virtual Function and Backward Compatibility example](030-virtual-function-and-bkwd-compatibility)

## Example - Virtual Function and Forward Compatibility

This example too demonstrates how CIB ensures ABI stability even when virtual table is disrupted. But in this one new client is run with old library. Also, forward compatibility of library means backward complatibility of client and so if newer client calls function that is available only in new library then new client will not work properly with old library unless it takes precautions.

For details please see [Virtual Function and Forward Compatibility example](035-virtual-function-and-forwd-compatibility)

## Example - Interface Classes

In this example we explore what pieces of architecture should be there to ensure calls made by library to client happens in ABI compatible and stable way.

For details please see [Interface Class example](060-simple-interface-class)

## Example - Interface Classes and ABI Stability

In this example we will see that how ABI stability is guaranteed when virtual table of interface class is disrupted.

For details please see [Interface Class And ABI Sytability example](070-simple-interface-class-and-bkwd-compatibility)

## Example - C++ Template Classes
In this example we consider what CIB architecture needs to do to support template classes and how concretized types of template class can cross component boundary in ABI compatible and stable way.

For details please see [C++ Template Classes example](100-template-classes)

## Example - Facade Classes and RTTI

Please see example `facade-classes-and-rtti` in `examples` folder.

**TODO**: Add detail documentation.

## Example - Non public virtual functions.

Please see example `private-virtuals` in `examples` folder.

**TODO**: Add detail documentation.

# Demo Project
For working demo see projects **graphics** and **draw** in `demo/functionality` folder.

**graphics** is the library that provides definition of various shape classes, like Circle, Rectangle, etc.
**draw** is the client of **graphics** that uses it to draw various shapes.
Folder **graphics/pub** contains files that graphics library wants to make public.

When **cib** is run, which is done as pre-build step, it creates files in **graphics/cib** and **graphics/exp**. These generated files use files in **graphics/pub** as input.
Files in **graphics/cib** are meant for **graphics** library to compile with.
Files in **graphics/exp** are part of SDK of library and meant for client of **graphics**, in this case **draw** project to compile with.

Build **draw** and run it. Make changes in headers of **graphics** and build just **graphics_cibified** and run **draw_cibified**. Observe that non-breaking changes listed above don't make **graphics_cibified** and **draw_cibified** incompatible. But those changes make **graphics** and **draw** (the binaries that don't use CIB) incompatible.

# Possible Optimization

## Layout Sharing Proxy Class
In a program there can be classes for which an isolated proxy class may not make too much sense. For example consider the following example:

!INCLUDECODE "examples/130-layout-sharing-proxy-classes/pub/example.h" (c++)

There is almost no chance that object layout of this class will change in future. Isolated proxy class is needed to completely isolate layout of objects used by library and client. The reason is that a future change in library can alter the object layout and will enforce clients to recompile if layouts are not isolated. For a class like `CPoint` defined above such chance is meager if not completely ruled out. So, library developer can take a call to dictate to CIB to create layout sharing proxy class instead of isolated proxy class. That has some benefits:
1. Memory is saved as layout is shared between client and library.
2. It is possible to share raw object array across component boundary which is not possible for isolated proxy objects.
 
But library developer, when decide to use layout sharing proxy class for a particular class, must be careful as they would, had it been a struct in a C library.

Please see example `layout-sharing-proxy-classes` for more detail.

# Limitations of CIB Architecture
CIB Architecture is good for ensuring ABI compatibility and stability. But unfortunately these goodness are not free. CIB architecture has limitations too:

| Limitation                                                  | Reason       | Workaround, if any |
| ---------------------------------                           | :----------  | :----------------- |
| Mandatory creation of proxy objects                         | The core philosophy of CIB is to not share internals with other components. For that reason each component have their own objects. The library objects used by client are used through proxies which are created at client side and act as if they are client side objects. So, for every library side object that client want to use, a corresponding proxy object is also created. It adds up to use of more memory and cost runtime performance too.                                                             | Use layout sharing proxy wherever applicable |
| Objects of library are always created on heap by the client | This is not true for layout sharing proxy classes but when client creates an object of isolated proxy object the corresponding object on library side is always created on heap.   | Use layout sharing proxy wherever applicable |
| Increased binary size and memory usage                      | Because of proxy objects and their special implementation using **MethodTable** binary size and memory usage of both library and client increases.                           | Use layout sharing proxy wherever applicable |
| Impact on runtime performance                               | CIB layers costs runtime performance too because there is no inline function across component, multiple function calls involved for a single call across component, and cross component function calls happen always through function pointer. | In practice these costs may not be significant. |
| No raw array of objects can cross component boundary in most cases | Except when the proxy class is layout sharing type it is not possible to share raw array of objects across component boundary.                                           | Return a container object instead or use layout sharing proxy wherever applicable. |
| In some cases explicit cleanup of proxy objects.            | Clients can only use library objects through proxies. And so when library returns an object which is not expected to be deleted then client will never delete the proxy object. Such object will be left without deletion and so they may need explicit cleanup. [See more on explicit proxy cleanup](#more-on-explicit-proxy-cleanup), and [Possible Improvement](#possible-improvement. | Use `shared_ptr`, or `unique_ptr`. Or, Use layout sharing proxy wherever applicable. |

## More on explicit proxy cleanup

The example of such cases can be 
- Singleton object whose creation and deletion is handled by library.
- Internal objects returned by library:
- A parameter of a callback invoked by library.

If the workaround mentioned above cannot be used then the only solution would be to explicitly delete those proxy objects using some special mechanism outside of regular program flow. Admittedly this will be dirty and so other solutions should be sought for, see [Possible Improvement](#possible-improvement).

# Possible Improvement
In the current implementation of CIB the association of library side object and proxy object is saved on the client side in a `map`. When a proxy object for a library side object is needed then unless there is no already existing proxy object available a new one is created. See example `proxy-object-reuse`.
CIB uses this implementation because the goal of CIB is to be minimally invasive, i.e. it doesn't want to change the way developer wants to define their classes. But if we can relax this restriction a little bit then the association between library side object and it's proxy objects can be stored in the library side object itself. The main benefit of this change will be to avoid the limitation where there is a need to explicitly clean the proxy objects. When a library side object is deleted then all associated proxy objects, if any, can be deleted too.

# CIB Terminology
## Inline Class
A class that has all methods inline. *For example a template class is surely an inline class*.
## Shared Class
A C++ class whose intances cross component boundary: *When a class is not an inline class or there exists a public function that returns or takes an object/pointer/reference of a C++ class then such class is called a shared class*.
## Facade Class
A C++ class that acts as facade for other classes: *A class that has public virtual method and there exists public function/method that returns a pointer/reference of this class*. Since the returned object can actually be a type of any of derived class the return type acts as facade for all it's derived classes.
## Interface Class
A C++ class that has public virtual method and there exists a way for library to call methods of an object of class defined by client.
*A simplest example can be that when a C++ class that has public virtual method is used as pointer or reference parameter of a function*.
## Proxy Class
For each public class of a library CIB produces another class with same name and behaviour. Such client usable classes are called proxy classes because they act as a proxy of original class to the client. There are 2 kinds of proxy classes:
  1. Isolated proxy class, aka bridge proxy class.
  2. Layout sharing proxy class. Both original and proxy class share same object layout.

**Note**: When simply `proxy class` is used then it always means `isolated proxy class`.
## Handle
Each isolated proxy class instance owns opaque pointer of the original class. Such opaque pointer are called handle.

# Implementation Details
## Parsing Technique
We use cppparser to parse C++ headers. Clang can be an option but since we do not need full and complete compiler level type resolution clang is not suitable for us. For example if a function is declared as:

`
void ExampleFunction(wxInt32 i);
`

cib doesn't need to resolve wxInt32. In-fact if it resolves it completely then it will be a problem because wxInt32 can be an **int**, or a **long** depending upon platform and cib really should produce same definitions on all platforms. The idea of cib is that it should produce same headers for all platforms so that it can be used to publish SDK because different headers for different platforms don't sound like a good idea.

## Creating proxy class from handle
When a function returns pointer to base class then it is necessary to create instance of proxy class which represents exact same class that the returned pointer is pointing to. For example if a function return type is Shape* and when invoked it actually returns pointer to a Rectangle instance. On client side we will need to create instance of Rectangle proxy class instead of Shape proxy class. It is to be noted that it has to be done only for facade classes for other classes there is no need for this.

**TODO**: Add more details.

